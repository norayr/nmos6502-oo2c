#	$Id: Errors.lst,v 1.45 2000/07/21 17:03:09 ooc-devel Exp $
# Each line starting with a "*" is expected to be of the form
# "* <number>: <text>", where <number> is a decimal constant in the 
# range 1..999, and <text> a short description of the associated error
# resp.  warning.  The description may contain upto two `%'
# characters.  The compiler will replace them with appropriate text.
# The resulting string shouldn't be longer than 75 characters.  All
# other lines are ignored by the compiler, although a tool (i.e., the
# editor, or the error lister) may extract them to provide further
# information regarding the given error.  These extended error
# messages are intended to help a novice user, e.g. by clarifying more
# obscure points of the language or the compiler.
# 
# This list is extracted from the OOCref info file.
################################


#    All implementations of OOC try to provide error messages that are as
# helpful as possible; the problem causing the message should be readily
# identifiable.  Counter examples to this approach are most C compilers.
# They combine a cryptic error text with a line number and leave it to
# the programmer to find out what might be wrong.
# 
#    OOC tries to precisely mark the faulty construct triggering an
# error.  It provides an exact position in the given piece of source
# code.  The error message has to interpreted relative to the context of
# this file position.  Without knowing the reference point, most error
# messages don't make sense.  Therefore, we strongly suggest to use an
# editor or other tool to display errors together with their context.
# 
#    Compilation continues after errors.  This usually works quite well,
# but sometimes error recovery will fail and many meaningless error
# messages will be emitted in succession.  Certain kinds of syntax errors
# can send the compiler down a completely wrong path.  In such cases, all
# but the very first error message should be ignored.
# 
#    Some of the error texts listed below contain the placeholder
# character `%'.  The compiler will replace the placeholders with
# identifiers, numbers, or text fragments.
# 
#    Implementations of OOC may introduce their own errors and warnings,
# starting at number 500 and ending at 998.


*1: Comment not terminated
     While reading the source code, the scanner found a `(*' with no
     matching `*)', even after searching to the end of the file.

*2: Illegal character in string
     An unprintable ASCII control code appears in the string.  That is,
     a character with an ASCII code in the range `00X..1FX'.  This
     restriction isn't explicitly stated in the Oberon-2 report, but it
     is implemented this way by the ETH compilers.  *Please note*: The
     character `0X' is actually interpreted as end of file marker by
     the scanner and a string containing it will generate the message
     `String not terminated'.

*3: String not terminated
     No terminating quote character was found before reaching the end
     of the line, which matched the one that started the string.  Keep
     in mind that it is not possible to embed the string's quote
     character in the string (i.e., a `"' cannot occur in `"..."', nor
     `'' in `'...'')  and that a string can't stretch over multiple
     lines.  *Please note*: This message will also be generated if the
     string contains the ASCII character `0X', which the scanner uses
     to mark the end of the file.

*4: No comment started
     The character sequence `*)' was found outside a comment.  Because
     no legal Oberon-2 program can contain this as a symbol sequence,
     it is assumed that it was intended to terminate a comment.

*5: Illegal cipher
     Any symbol starting with a decimal cipher is considered to be a
     number.  It extends to the first character not in the ranges
     `0..9' or `A..F', plus a possible suffix `X' or `H'.  Without one
     of those suffixes, only decimal digits are allowed and any
     character from `A..F' will be considered as an invalid cipher.
     For a real number's exponent, only the characters `0..9' are valid.

*6: Number out of range
     The value of the numeric constant is too large to be converted
     into the internal representation.  Four cases have to be
     distinguished:

        * A decimal integer constant (or a real number's exponent) has
          to be less or equal to `MAX(LONGINT)'

        * A hex number has to be in the range `0H..0FFFFFFFFH'

        * A `REAL' number (i.e., a real constant without any exponent
          or with the exponent symbol `E') has to be less than or equal
          to `MAX(REAL)'

        * A `LONGREAL' number (i.e., a real constant with the exponent
          symbol `D') has to be less or equal to `MAX(LONGREAL)'

     *Caution*: Hex constants in the range `08000000H..0FFFFFFFFH'
     would exceed `MAX(LONGINT)' when interpreted as positive and are
     actually mapped onto negative values in the range
     `MIN(LONGINT)..-1' matching the bit pattern of the unsigned
     constant.

*7: Not a valid character constant
     Character constants have to be in the range `0X' to `0FFX'.

*8: Illegal symbol
     All characters that have no special meaning in Oberon-2 (such as
     `!', `%', etc.) cause this error message when they appear in the
     symbol stream.  They are only permitted as part of comments or
     string constants.

*9: Illegal exponent format
     The exponent following the mantissa of a real number has to comply
     to the syntax `[D|E][+|-]digit{digit}'.  This means the exponent
     marker (`D' for `LONGREAL', `E' for `REAL') must be followed by an
     optional sign and a non-empty sequence of decimal digits.

*10: Illegal character
     An underscore cannot be used in identifiers except for within
     `INTERFACE' modules and when refering to objects declared in
     `INTERFACE' modules.

*11: No pragma command started
     The character sequence `*>' was found without a preceding `<*'.

*12: Nested `<*' not allowed
     The token `<*' was found inside a pragma, although a pragma inside
     another pragma is not permitted.

*13: `IF' statement lacks `END'
     An `IF' statement appears inside a pragma, but there is no matching
     `END' before the end of the file.

*14: No open `IF' statement
     An `ELSIF', `ELSE', or `END' statement appears inside a pragma
     without any preceding (and still open) `IF' statement.

*15: `ELSE' part already defined
     The indicated `ELSIF' or `ELSE' statement is part of an `IF'
     statement that already defines an `ELSE' statement.

*16: Pragma stack empty
     At the place of the `POP' statement, the stack of pragma variables
     is empty.  In order to do a `POP', a `PUSH' has to be done
     beforehand.  Having more `PUSH's than `POP's is allowed, but the
     reverse isn't true.

*17: Undeclared pragma variable
     A pragma variable has to be defined before being used in an
     expression or for the left hand side of a (non-defining)
     assignment. Such a definition can be done in the configuration
     file, or in a pragma, by prefixing an assignment statement with
     the keyword `DEFINE'.  There is also a command line option to
     introduce defines.

*18: Pragma variable already defined
     Each pragma variable can only be defined exactly once.  After its
     definition, all subsequent assignments have to be non-defining
     ones. That is, they must not be prefixed with `DEFINE'.

*19: Value cannot be assigned to % variable
     The initial definition of a pragma variable assigns a type
     (boolean, integer, or string) to it.  All subsequent assignments
     have to assign values of the same type.

*20: Boolean expression expected
     The expression at the indicated location must evaluate to a
     boolean value.

*21: Illegal variable name
     The pragma keywords `TRUE', `FALSE', `PUSH', `POP', and `DEFINE'
     cannot be used as names of pragma variables.

*30: String too long (maximum is % characters)
     The given string value exceeds the hard limit the compiler imposes
     on the length of string constants.  You'll have to split the
     constant into several smaller ones and concatenate them together
     in a character array variable.

*31: Warning: String longer than % characters
     The given string value exceeds the soft limit for the length of
     string constants.  Check the documentation of your particular
     compiler implementation for the implications.

*32: Identifier too long (maximum is % characters)
     The indicated identifier exceeds the hard limit the compiler
     imposes on the length of identifiers.  Replace the name with a
     smaller one.

*33: Warning: Identifier longer than % characters
     The indicated identifier exceeds the soft limit for the length of
     identifiers.  Check the documentation of your particular compiler
     implementation for the implications.

*34: Warning: Hexadecimal constant is mapped to negative value
     When hexadecimal constants are greater than the maximum value of
     the largest integer type, they are mapped onto negative values.
     For example, if the compiler does not support the `HUGEINT' type,
     hex constants in the range `08000000H..0FFFFFFFFH' are mapped onto
     negative values in the range `MIN(LONGINT)..-1' matching the bit
     pattern of the constant.  If `HUGEINT' constants are available
     they are mapped onto the positive `HUGEINT' values `2^31..2^32-1'.
     This means that the interpretation of such constants depends on
     the compiler.  Without special precautions modules using them are
     not portable to systems that support additional, larger integer
     types.

*35: Malformed module identifier
     A module identifier with a non-empty path prefix must satisfy the
     regular expression `[a-zA-Z][a-zA-Z0-9]*(:[a-zA-Z][a-zA-Z0-9]*)*'.

   The following error messages indicate that the compiler expected a
different symbol at the indicated position than it actually got.  In
other words, the current symbol doesn't fit into the current
syntactical context.

*100: Identifier expected

*109: `=' expected

*118: `.' expected

*119: `,' expected

*120: `:' expected

*122: `)' expected

*123: `]' expected

*124: `}' expected

*125: `OF' expected

*126: `THEN' expected

*127: `DO' expected

*128: `TO' expected

*130: `(' expected

*134: `:=' expected

*137: String expected

*139: `;' expected

*141: `END' expected

*144: `UNTIL' expected

*163: `MODULE' expected

*166: `*>' expected

*180: Unexpected symbol

*181: Factor starts with illegal symbol

*182: Data type expected

*183: Statement expected

*197: Undeclared identifier
     The indicated identifier is not associated to any definition.
     With the exception of names used as pointer base types (e.g., the
     name `T' in `POINTER TO T'), all identifiers have to be declared
     prior to their use.  This declaration has to appear in the local
     scope or in one of the enclosing scopes textually before any using
     occurrence of the name.

*198: Identifier `%' expected
     The identifier given at the end of a procedure or module has to be
     the same as the name that was assigned to the respective procedure
     or module in its heading.

*199: %
     This error message can be filled by the compiler with arbitrary
     text.

*200: Export only possible on top level
     Only declarations on a module's top level can be part of the
     public interface of the module.  All names defined inside a
     procedure are local to their respective procedure and are not
     visible outside.

*201: Can only be exported with `*'
     Constants, types, and procedures cannot be exported with `-'
     because the notion of a restricted, read-only access doesn't make
     sense for these objects.

*202: Has to be exported like inherited declaration
     A redefinition of a type-bound procedure in an extended type has
     to be exported if the base definition was marked as exported.  In
     other words, if the type-bound procedure `P' in `T' is exported,
     then all redefinitions of `P' in extensions of `T' have to be
     exported as well.

*203: Can't use type constructor here
     Oberon-2 type rules prevent calls of a procedure whose parameter's
     type is defined by a type constructor.  Such a formal parameter
     won't match any actual parameter.  The only exception to this rule
     is open array parameters, where the actual parameter is required
     to be array compatible (see Appendix A of the language report)
     with the formal one.

*204: Receiver has to be a record or a record pointer
     The type of the receiver parameter of a type-bound procedure is
     restricted to record or record pointer types.  In the former case,
     the receiver has to be a variable parameter, and a value parameter
     in the latter.

*205: Illegal type for function result
     An Oberon-2 function cannot return a structured result.  If a
     procedure has to pass a record or array value back to the caller,
     a variable parameter has to be used instead.

*206: Can't use type constructor here
     The type expression denoting the result type of a function
     procedure has to be the name of an unstructured type.  Otherwise,
     the Oberon-2 type rules would prevent the use of the function as
     part of an expression.

*207: Illegal pointer base type
     Pointers can only refer to record or array types.  An open array
     can be used as pointer base type.  It is not possible to define a
     pointer to one of the predefined types, to a procedure type, or
     another pointer.

*208: Open array can't be used here
     Oberon-2 imposes certain restrictions on the use of open array
     types.  Such a type can only appear as type of a procedure
     parameter (to relax the rules for passing array values to
     procedures), as pointer base type (to be able to allocate arrays
     of arbitrary size on the heap), and as element type of another
     open array (to implement multi-dimensional open arrays).  All other
     applications of open arrays are illegal.  An open array type can
     have a name.  That is, a declaration of the form `TYPE S=ARRAY OF
     CHAR;' is legal.

*209: This has to be an integer constant
     This applies to two cases:

        * The length of a fixed size array type has to be a positive
          integer constant.

        * The increment value of a `FOR' loop has to be a non-zero
          integer constant.

     Note that wherever a constant value is required, a constant
     expression can be used.

*210: Arrays of negative length are not allowed
     The length specified for a dimension of an array type has to be a
     non-negative integer value.  A length of zero is allowed even
     though it isn't possible to access an element of such a variable.

*211: Data type expected
     The name at the indicated location has to refer to a type
     definition.

*212: This record type cannot be extended
     The given name refers to a record type that cannot serve as a base
     type for extension.  This usually means that the record was
     defined as part of an interface module for another language (e.g.,
     C).  Such a foreign type is not associated with any kind of meta
     information (i.e., type descriptor), which is necessary to
     implement type extension.

*213: This has to be a record type
     The name given inside parenthesis after the keyword `RECORD' has to
     refer to a record type.

*214: Receiver of pointer type has to be a value parameter
     If the type of the receiver of a type-bound procedure is a record
     pointer, it has to be defined as a value parameter.

*215: Receiver of record type has to be a variable parameter
     If the type of the receiver of a type-bound procedure is a record,
     it has to be defined as a variable parameter.

*216: Illegal receiver type
     The type of a receiver parameter is restricted to record or
     pointer to record.

*217: This has to be a top level type
     Any record type serving as an anchor to a type-bound procedure has
     to be defined on the top level of the current module.  It cannot
     be imported because this would imply a modification of the
     interface of a type that isn't defined in (and under the control
     of) the local module.  Also, a record defined inside a procedure
     cannot serve as receiver type because all type-bound procedures
     have to be global.  This is required for the same reason that only
     global procedures can be assigned to variables: a nested procedure
     can only be executed in the context of its enclosing procedure,
     whereas type-bound procedures (and procedure variables) can be
     activated anywhere.

*218: Type-bound procedure has to be declared on top level
     A type-bound procedure has to be declared on the global level of
     the module that defines its anchor record.  This is required for
     the same reason that only global procedures can be assigned to
     variables: a nested procedure can only be executed in the context
     of its enclosing procedure, whereas type-bound procedures and
     procedure variables can be activated anywhere.

*219: Multiple forward declaration of same name
     A procedure is forward declared multiple times.

*220: Formal parameters don't match forward declaration
     The formal parameters of the procedure definition do not match the
     ones of the previous forward declaration.  This means that there
     is a difference in the number of parameters, one of the parameter
     types or mode (i.e., value or variable), or the result type.

*221: Receiver doesn't match forward declaration
     The receiver type of the procedure definition does not match the
     previous forward declaration.  With the language restrictions on
     receivers, this can only mean that the forward declaration uses a
     pointer receiver and the declaration a record, or vice versa; both
     must use the same kind of receiver.

*222: Export mark differs from forward declaration
     The export status of a procedure definition has to match the
     forward declaration (if present).  Either both of them must have
     an export mark, or neither.

*223: Formal parameters don't match inherited declaration
     One of the base types of the type-bound procedure's anchor record
     declares a procedure of the same name, but the formal parameters
     of both procedures do not match.  If the current declaration is
     intended to be a redefinition of the previous procedure, it is
     necessary to adjust the formal parameter list.  If it is intended
     as a new procedure, the name has to be changed.

*224: Receiver doesn't match inherited declaration
     One of the base types of the type-bound procedure's anchor record
     declares a procedure of the same name, but with a receiver of a
     different mode.  With the restrictions on receivers, this can only
     mean that the base declaration uses a pointer receiver and the
     current declaration a record, or vice versa.  Both must use the
     same kind of receiver.

*225: Field of this name already declared in extension `%'
     The name of the indicated type-bound procedure conflicts with that
     of a field defined in one of the extensions of its receiver's
     anchor record.  In other words, the type-bound procedure `P' is
     bound to the record `R' and a record `R0' extending `R' (in the
     local module) defines a field that is also called `P'.  This would
     imply that the record `R0' actually contains two objects called
     `P': its own record field and an inherited type-bound procedure.
     This violates the rule that an identifier has to refer to an
     unique object in its scope.

*226: This procedure has already been declared in extension `%'
     The name of the indicated type-bound procedure conflicts with that
     of a previously declared procedure bound to one of the extensions
     of its receiver's anchor record.  In other words, the type-bound
     procedure `P' is bound to the record `R' and a record `R0'
     extending `R' (in the local module) also defines a type-bound
     procedure `P', but the latter procedure is declared first.  If the
     order of declaration of the two procedures is reversed (i.e., the
     procedure bound to the extension declared after the one of the
     base type), the former would be recognized as a redefinition of
     the latter and everything would be fine.  But when written in the
     wrong sequence, the single-pass compiler cannot handle this
     properly and flags it as error.

*227: Not a record (is `%')
     The left side of a field or type-bound procedure selector has to
     be a record or a record pointer value.

*228: Not a pointer (is `%')
     The left side of a dereference operator has to be a pointer value.

*229: `%' has no base type
     For a super call of the form `x.P^()', the type of `x' has to be a
     true extension of another type that also defines the type-bound
     procedure `P'.

*230: Procedure `%' not declared in base type
     For a super call of the form `x.P^()', the type of `x' has to be a
     true extension of another type, which provides the the original
     definition of the type-bound procedure `P'.

*231: Operator not applicable to type `%'
     The indicated operator cannot take a value of the given type as an
     operand.

*232: Value expected instead of a data type
     The name given as an operand refers to a type instead of a value.
     Type names are only applicable in type constructors, variable and
     parameter declarations, and certain predefined functions like
     `MIN', `MAX', `SIZE', and `SYSTEM.VAL'.

*233: Operand incompatible to left hand side `%'
     The operator is not applicable to values of the given types.  See
     Appendix A of the language report for a list of legal argument
     types for the operator.

*234: % expression expected (instead of `%')
     This applies to the following cases:

        * The index of an array selector has to be an integer value.

        * A set element has to be an integer value.

        * The guard of an `IF', `WHILE', or `REPEAT' statement has to
          be a boolean expression.

*235: This item has no memory address
     `SYSTEM.ADR' is only applicable to variables, procedure names, and
     string constants.

*236: Lower bound has to be less or equal to upper bound
     If both bounds `a' and `b' of a set constructor `{a..b}' are
     constant, then `a <= b' has to hold.  The compiler assumes `a > b'
     to be an error because otherwise the result would be the empty set
     `{}'--which is most likely not what the programmer wanted in the
     first place.  The same holds for a range of labels in a `CASE'
     statement.

*237: This has to be a character constant
     If the select expression of a `CASE' statement is a character
     value, then the labels of the case branches have to be character
     constants.

*238: This has to be a constant expression
     The language requires constant values to be used for the right
     side of a constant declaration, an array's length, the step
     constant of a `FOR' statement, and the labels of a `CASE'
     statement.  A constant expression may contain constant values and
     applications of predefined operators and functions.  For example,
     the declaration `CONST m=10*MAX(SET);' would be legal and
     equivalent to `m=310'.  Note that every integer constant
     expression is assigned the smallest integer type containing the
     given value *after* the whole expression has been evaluated.  For
     the above example, `m' would be of type `INTEGER'.

*239: Not assignment compatible to type `%'
     The referenced expression is not assignment compatible to a
     variable of the indicated type.  The right side of an assignment
     statement has to be assignment compatible with the variable on the
     left side, an argument of a procedure call corresponding to formal
     value parameter has to be assignment compatible with the type of
     the parameter, and the argument of an `RETURN' statement has to be
     assignment compatible with the result type of its function.
     Appendix A of the language report lists the rules for assignment
     compatibility.

*240: This isn't a function procedure
     The definition of proper procedure cannot contain `RETURN'
     statements with an argument.

*241: Missing function result
     Every `RETURN' statement appearing as part of the definition of a
     function procedure has to have an argument describing the
     function's result value.  The argument has to be assignment
     compatible to the function's result type.

*242: `EXIT' not within a `LOOP'
     The indicated `EXIT' statement is not part of a `LOOP' statement.
     `EXIT' can only be used inside a `LOOP', although it may be nested
     arbitrarily deep into other statements.  An `EXIT' always refers
     to the nearest enclosing `LOOP'.

*243: Not an array (is `%')
     The element selector `[...]' may not be used on a variable
     designator that isn't of array or array pointer type.

*244: This isn't a variable designator
     This applies to the following cases:

        * Only a modifiable variable designator may appear on the left
          side of an assignment statement.  The variable designator may
          not refer to a variable or record field that has been
          exported as read-only.

        * The control variable of a `FOR' statement has to be an
          unqualified (i.e., local) variable identifier.

     Note that dereferencing a read-only pointer variable will grant
     unrestricted access to the pointer's contents.

*245: This is imported read-only
     This applies to the left side of an assignment statement and to
     variables passed to a `VAR' parameter as part of a procedure call.
     This means that the destination variable (or designator) has to
     be either

       1. imported as read-write (and no following selector accesses a
          read-only record field), or

       2. the value of a dereferenced pointer variable.

     Contrary to a pointer dereference, an element of a read-only array
     is read-only, just like a field of a read-only record variable.

*246: Too many parameters (maximum is %)
     The number of declared parameters exceeds the compiler's limit.
     You will have to reduce their number; for example, by moving some
     of the parameters into a single record, and passing this record to
     the callee.

*247: Not a procedure (is `%')
     The designator to the left of an argument list does not denote a
     procedure or a procedure variable.

*248: More actual than formal parameters
     The argument list of the procedure call contains more parameters
     than specified in the procedure's formal parameter list.

*249: Parameter expected
     The argument list of the procedure call contains fewer parameters
     than specified in the procedure's formal parameter list.

*250: Not array compatible to formal parameter `%'
     The actual parameter of the procedure call is not array compatible
     to the formal value parameter specified in the procedure heading.
     The formal and actual parameter must either

       1. have the same type, or

       2. the formal parameter is an open array and their element types
          are array compatible, or

       3. the formal parameter is an `ARRAY OF CHAR' and the actual
          parameter a string constant.

     Note that a character constant (e.g., `"a"' or `41X') is also a
     string constant.  For details see Appendix A of the language
     report.

*251: Not compatible to formal variable parameter `%'
     The indicated argument cannot be passed to the corresponding
     formal variable parameter specified in the procedure heading.  For
     the type of the formal parameter TF and the type of the actual
     parameter TA one of the following statements has to hold:

        * both are of the same type

        * TF is a record, and TA is an extension of TF

        * TF is an open array, and TA is array compatible with it

        * TF is `SYSTEM.BYTE', and TA is `CHAR', `SHORTINT', or
          `SYSTEM.SET8'

        * TF is `SYSTEM.PTR', and TA is a pointer type

     Note that special rules apply for the arguments of predefined
     procedures of the language.

*252: This isn't a proper procedure
     A function procedure cannot be activated as if it were a proper
     procedure.  That is, unlike C, Oberon-2 does not discard the
     function's result automatically.  In such a case, the result may
     be discarded by assigning it to an unused variable.

*253: This isn't a function procedure
     A proper procedure cannot be activated as if it were a function.

*254: This has to be a simple identifier
     The control variable of a `FOR' statement is restricted to local
     variables (or parameters) of the current procedure, of enclosing
     procedures, or the module.  It is not possible to use an imported
     variable or a variable designator containing any selectors.

*255: Has to be a nonzero integer constant
     The increment value of a `FOR' statement must be a nonzero constant
     value.

*256: Too large with respect to control variable of type `%'
     The increment value of a `FOR' statement has to be included within
     the range of the type of the control variable.

*257: This variable has no dynamic type
     A type test is only applicable to variables whose dynamic type
     (i.e., the type during run time) may differ from their static one
     (i.e., the type specified when compiling).  This means that the
     variable either has to be a record pointer, a dereferenced record
     pointer, or a variable parameter of record type.  Note that record
     types defined as part of an interface module for another language
     will lack any Oberon-2 run-time type information.  Those records
     (and pointer types derived from them) cannot be subjected to type
     tests or type guards.

*258: This isn't a record pointer
     Only record pointers (and variable parameters of record type) can
     be subjected to type tests or type guards.

*259: This type is no extension of the variable's type
     A type used for a type test or type guard has to be an extension
     of the tested variable's type.  For a record, this means that the
     variable's type has to be a direct or indirect base type of the
     given type.  For a pointer, this relation has to hold for the
     pointer base types.  Note that testing a variable against its own
     type is possible, but redundant.

*260: Integer or character expression expected
     The select expression of a `CASE' statement must be either of type
     integer, or of type character; boolean, real, or complex
     expressions are not allowed.

*261: Case label not included in type of case selector
     The case label lies outside the range of values the select
     expression can possibly assume.

*262: Case labels (%..%) already used
     The given range of values is already assigned to another `CASE'
     branch.  The labels of any two branches have to be distinct.

*263: Has to be a (qualified) identifier
     The language only allows application of a regional type guard to
     simple variables.  Complex designators (variables followed by a
     nonempty list of selectors) are not permitted.  However, the
     variable can be imported from another module.

*264: This type has no `MIN'/`MAX' value
     The predefined functions `MIN' and `MAX' are only applicable to
     integer, real, and set types.  For the numeric types, they return,
     respectively, the smallest and largest values a variable of the
     given type can assume.  For set types, they return the smallest
     and largest valid set elements.

*265: Value incompatible with variable
     The second argument of an activation of `INC' or `DEC' must be a
     value that is included in the type of the first argument.  If
     conformant mode is enabled, and the second argument is a
     non-constant expression, the second argument has to have the same
     type as the first argument.

*266: This type has no fixed size
     The predefined function `SIZE' cannot be applied to open array
     types because these types represent a set of arbitrarily sized
     variable instantiations during run time.  In other words, such
     types don't have a size.  Variables of those types do have a fixed
     size, but `SIZE' is not applicable to variables.  To get the size
     of an open array variable, you would have to multiply the size of
     the array element type by the array's length.

*267: Illegal definition for a previously used pointer base type
     If the base type `T' of a type `POINTER TO T' is defined later in
     the text, `T' has to be declared as a legal pointer base type.
     That is, it must be a record or an array type.

*268: Cannot copy this value to `%'
     The predefined procedure `COPY' cannot copy a string composed of
     `LONGCHAR' characters to an array of `CHAR' elements.  It can copy
     towards an array using the same character type, and to a larger
     character type.  In the latter case the function `LONG' is applied
     to every character.

*269: Cannot modify value parameter that has no local copy
     For an open array value parameter with `NO_LENGTH_TAG', the
     compiler cannot create a local copy of the array argument.  This
     means that it cannot guarantee the normal semantics of value
     parameters.  (Recall that value parameters normally follow these
     rules: local modifications to the parameter stay local, and
     modifications to the variable that was passed to the parameter are
     not reflected in the parameter's local value.)

     In this case, instead of the standard behaviour, the compiler
     treats the parameter like a read-only variable and prevents *local
     changes* to the parameter's value.  However, any changes to the
     original *array variable*, which was passed to the parameter in
     the first place, are reflected by the parameter's value.  This
     resembles the semantics of the keyword `const' when applied to C
     pointer types.

*280: No information on length of variable available
     It is attempted to perform an operation on an array variable that
     needs to compute the array's length.  This error can occur only in
     connection with types or procedures defined in interface modules
     to other languages.

*281: This type has no type descriptor
     An attempted operation on a record variable needs to compute the
     record's dynamic type, and that type information is not available.
     This error can occur only in connection with types or procedures
     defined in interface modules to other languages.

*282: NEW cannot allocate memory for this type
     The predefined function `NEW' is not applicable to non-standard
     types; that is, types that do not follow the rules of Oberon-2.
     Such types are usually introduced by interface modules providing
     access to programs written in other languages.  If the interface
     does not provide a way to allocate heap objects of this type, you
     will have to use `SYSTEM.NEW'.

*300: Unresolved forward declaration
     This applies to both forward declarations of procedures, and to
     base types of pointers.  Every forward declaration of a procedure
     has to be resolved by a procedure definition of the same name
     within the same scope.  The definition's formal parameters must
     match the ones of the forward declaration, and both declarations
     have to share the same export status.  For every undeclared type
     `T' appearing as base type of a `POINTER TO T', there has to be a
     definition of `T' as a record or array type within the same scope.

*301: Multiple declaration of same name
     Within a single scope multiple declarations share the same name.
     This conflicts with the Oberon-2 rule that every object has an
     unique name within its scope.

*302: `%' imports `%' with illegal key
     The symbol file of the first module contains a key for second
     module that differs from the one read from the second's symbol
     file.  This usually means that these symbol files are out of sync.
     Normally, the make facility ensures that the exported and the
     imported interfaces match, although direct manipulations of the
     (compiler generated) files and problems with files' time stamps
     may defeat it.  The latter case can happen when different clocks
     apply for source files and generated files; for example, when the
     sources are read over NFS and the compiler generated files are put
     onto a local hard disk.  If nothing else helps, the compiler
     should be run with `--make --all', forcing recompilation of all
     files whose sources are available.

*303: Can't open/read symbol file of module `%'
     The symbol file for this module either does not exist, or the user
     has no read permissions for it.  In the first case, it can be
     compiled by hand, or by telling the compiler to do a make.  The
     latter case probably means that something is amiss in the compiler
     installation (contact the person who installed your compiler) or
     the local setup (check the configuration files and compiler
     options).

*304: Symbol file `%' starts with illegal key
     The compiler found a file that should contain a module's exported
     interface, but the file does not start with the required magic
     number.  The file was probabably corrupted and should be deleted.

*305: Unexpected end of symbol file `%'
     The symbol file ends without containing all the data expected by
     the compiler.  The file was probably corrupted and should be
     deleted.

*306: A module cannot import itself
     The name of a module cannot appear as part of its own import list.

*307: Can't find module `%'
     During a make, the indicated module name appears in an import
     list, but neither the module's symbol file nor its sources can be
     found.

*308: Invalid symbol file format (format id is %)
     The format identifier of the symbol file is not supported by the
     compiler.  This usually means that symbol files of compilers for
     different target architectures have been mixed up.

*309: This name is already defined in base type `%'
     The field name conflicts with the name of a field or type-bound
     procedure inherited from one of the record's base types.  Note
     that multiple fields, and type-bound procedures, can share the
     same name as long as their declarations in the base type are not
     visible within the current module.  That is, when the base type is
     defined in another module and the declarations in question aren't
     exported.

*310: Invalid symbol file version (version is %)
     The version number of the symbol file format doesn't match the
     compiler.  This usually means that the symbol file was written
     with an older version of the compiler and that the new compiler
     has changed the file format.  The out-of-date symbol file should
     be deleted.

*350: Overflow during constant folding
     Evaluation of the constant expression resulted in a value that
     cannot be represented by the compiler.  For an integer expression,
     this means that the result is not a valid `LONGINT' (or possibly
     `HUGEINT') value.  If it is a real expression, then the resulting
     value isn't representable for the given real type.

*351: Division by zero
     A constant expression (real or integer) divides by zero.

*352: Constant not representable as `%'
     An attempt is made to convert a constant expression to a type that
     cannot hold the expression's value.

*353: Set element out of range %
     Any element index of a set operation has to satisfy the relation
     `MIN(S) <= e <= MAX(S)', where `S' is the applicable set type.
     Such errors are detected during compilation if the element index
     is a constant expression.  Otherwise, the compiler inserts
     appropriate run-time checks (unless disabled).

*354: Index out of range %
     The constant index doesn't denote a valid array element.

*355: Constant parameter out of range %
     A constant value in a valid range is required by the predefined
     procedures `LEN' for its dimension argument, and `ASSERT' and
     `HALT' for their trap number argument.  For `LEN', the constant
     has to satisfy `0 <= c < dim(T)', where `T' is the type of the
     array variable.  For `HALT' and `ASSERT', the limits depend on the
     target system.

   The following items are warnings generated by the compiler.  The only
difference to errors is that a warning will not cause termination of a
make.

     Some explanations regarding warnings about uninitialized variables
     should be considered: The compiler will try to detect possible
     uses of a variable in a procedure or module body where the
     variable has an undefined value.  This means that the variable
     could take on different values depending on the program state and
     environment, causing the program to behave randomly.  In this
     case, a warning is emitted based upon examination of the possible
     paths through the statement sequence.  The warning is not
     necessarily appropriate because the analysis does not take guards
     of conditional statements into account, but rather assumes that
     every path through an conditional statement can be combined with
     all paths through any of the subsequent statements.  Note that the
     compiler only checks the data flow of scalar values this way;
     record and array variables are ignored.  The compiler also ignores
     variable definitions by means of `SYSTEM.MOVE' when looking for
     uninitialized variables.

*400: Warning: Module name differs from file name `%'
     Although strict correspondence between a module's name and the
     name of its source file is not required, a name mismatch might
     lead to confusion.  The name given in a module's header determines
     the names for the generated (symbol and object) files.  Also, when
     the make facility parses an import list, it uses the name from the
     list to derive the file name.  A name mismatch might lead to the
     situation that a module called `X' is imported as module `Y'.  It
     is advisable to keep module and file names the same.

*401: Warning: Symbol file imported as `%' calls itself `%'
     While reading a symbol file for a module `X', it is discovered
     that the imported module as been compiled with the name `Y'.  See
     warning `400' for reasons to avoid such a name conflict.

*402: Warning: Ignoring last % bytes of file `%'
     The symbol file has been parsed successfully, but there are still
     bytes left in the file.  The file has probably been corrupted and
     should be deleted.

*403: Warning: Parameter name differs from forward declaration
     The language report states that formal parameters of a forward
     declaration must match that of the procedure definition.  However,
     corresponding parameter *names* are not required to match.  A
     warning is issued because using different names might lead to
     confusion.

*404: Warning: Variable is used uninitialized
     The compiler detected the use of a variable that has not been
     assigned a value beforehand.

*405: Warning: Variable may be used uninitialized
     The compiler detected the potential use of a variable that might
     not have been assigned a value beforehand.

*406: Warning: Function procedure contains no `RETURN' statement
     If a function procedure does not contain a `RETURN' statement, it
     cannot be left in a legal way.  Reaching the end of the function
     will trigger a run-time check (unless disabled).

*407: Warning: Control reaches end of function procedure
     The compiler detected a potential path through a function
     procedure that does not end in a `RETURN' statement.  This means
     that under certain circumstances the end of the function could be
     reached without a proper return value.  Like warnings about
     undefined variables, this message might not be totally accurate.

*408: Warning: Loop will never terminate
     The `LOOP' statement does not have any associated `EXIT'
     statement, and it also does not contain a `RETURN' statement.  This
     means that the loop will never terminate unless the program as a
     whole is aborted.

*409: Warning: Redundant type guard
     This type guard is the same as the static type of the variable.
     Because the guard asserts that the variable's dynamic type is the
     same as its static type (or an extension of the static type), this
     will always be true (unless the variable's value is `NIL').  In
     these cases, the type guard can usually be safely removed.

*410: Warning: Type test always evaluates to `TRUE'
     This type test is the same as the static type of the variable.
     Because the type test asserts that the variable's dynamic type is
     the same as its static type (or an extension of the static type),
     this will always evaluate to `TRUE' (unless the variable's value
     is `NIL').

*411: Warning: Formal parameter type modified by `WITH' statement
     This warning is emitted only if conformant mode is enabled.  In
     this case, care must be taken when a regional type guard is
     applied to a formal parameter.  The `WITH' statement will not only
     change the parameter's type locally, but also its type in the
     procedure's formal parameter list.  This in turn might break
     recursive calls to the procedure from within the regional type
     guard that depend on the type of the parameter as stated in the
     procedure heading.  Note that this is implemented in OOC because
     OP2 based ETH compilers handle it this way.  (This strange
     behaviour is not warranted by the language report in our opinion.)
     Disabling conformant mode will restrict effects of `WITH'
     statements to the inside of the statement without modifying any
     formal parameter list.

*412: Warning: Guard never reached
     Whenever testing a variable successively with a regional type
     guard, it is easy to construct one with branches that will never
     be reached.  Example: `WITH v: P1 DO ... | v: P2 DO ... END',
     where `P2' is an extension of `P1'.  Because `v IS P2' implies `v
     IS P1', a variable of dynamic type `P2' will always take the first
     branch and never reach the second.  Simply swapping the branches,
     writing the one that tests for the most special case first, will
     fix this.

*413: Warning: Cast converts between types of different size
     The results are unpredictable if a type cast (i.e., `SYSTEM.VAL')
     casts between types of different sizes.  Such a cast depends on
     the storage layout and the byte ordering of the target system and
     generally should be avoided.

*414: Warning: Procedure may read uninitialized `%'
     The compiler detected the potential use of a local variable during
     the activation of a nested procedure that might not have been
     assigned a value beforehand.  [NOTE: This warning has been
     disabled because it is also emitted if a local procedure writes to
     a variable of the caller that isn't defined at the place of the
     call, even if the called procedure never reads this undefined
     variable.  For technical reasons the compiler can't currently
     suppress this misleading warning.]

*415: Warning: Variable parameter may be used uninitialized
     The compiler detected the potential use of a local variable
     through a variable parameter that might not have been assigned a
     value beforehand.

*416: Warning: Call may change guarded variable `%'
     It is possible to circumvent a regional type guard by calling a
     procedure that has direct access (through the scoping rules) to
     the guarded variable.  Because the called procedure may assign any
     value to the variable, it can change its dynamic type at will,
     invalidating the guard after the procedure call.  The compiler is
     able to detect that the call of a nested procedure changes a
     guarded variable and issues this warning.  It normally does not
     recognize such a situation if the called procedure has been
     imported from another module.

*417: Warning: Cast converts to type with higher alignment
     Casting a variable of, say, alignment 2, to a type with an
     alignment of 4 may cause a run-time error if the variable is only
     2-aligned by chance and the target architecture does not allow
     misaligned accesses.  Generally such a situation should be avoided.

*418: Warning: Defining an array of size zero
     The indicated type definition specifies a length of zero for one
     of the array dimensions.  This will create an array of size zero.
     While such an array variable is legal, it isn't possible to access
     an element of a variable of this type.  However, such a variable
     can be passed to an open array parameter.

*419: Warning: Allocating an array of size zero
     The indicated call to `NEW' allocates an array with a length of
     zero for the given dimension.  This will allocate an array of size
     zero.  While this isn't considered an error, it isn't possible to
     access an element of a heap object of this type.  However, such an
     object can be passed to an open array parameter.

*420: Warning: Unused object
     The designated name is never used anywhere in the program.
     Therefore, its declaration can safely be removed without
     invalidating the module.  Note that the compiler only checks that
     there is no using occurrence of the name anywhere.  If one exists,
     the declaration is assumed to be used.  For this reason, recursive
     data types are never marked as unused because the record type
     refers to the pointer type and vice versa, providing uses for both
     the record and the pointer type even if they don't appear anywhere
     else.

*450: Type must not be abstract
     The indicated type is abstract and cannot be instantiated.
     Abstract types cannot be used for variable, record field, or array
     type declarations.  A pointer to an abstract type cannot be used
     as an argument to the `NEW' procedure.

*451: Type-bound procedure `%' still abstract
     The indicated type is concrete and has not implemented the named
     inherited abstract method.  Concrete types must implement all
     inherited abstract methods.

*452: Receiver type is not declared "abstract"
     The indicated procedure is declared abstract, but is bound to a
     concrete type.  Abstract procedures may only be bound to abstract
     types.

*453: No BEGIN section permitted in abstract procedure
     The indicated `BEGIN' statement is illegal because it occurs in an
     abstract procedure.  Abstract procedures cannot contain an
     implementation.

*454: Super call to abstract procedure
     The indicated procedure is abstract in the base class.  It is
     illegal to call an abstract method via a super call.

*455: Abstract procedure must be exported
     All abstract procedures must be declared with an export mark.

*456: Variables of this type are not allowed
     Instances of this type can only be created using NEW.  It cannot
     serve as the type of a variable declaration, a record field 
     declaration, or array base type.

*457: Cannot perform super call for this receiver type
     The receiver type's base type has no type descriptor, and therefore
     does not permit static calls to its type-bound procedures.

*999: Unexpected compiler termination
     Either the process was killed by an external signal, or the
     compiler aborted due to an internal run-time error.  The latter
     case should not happen; but if it does, check the compiler's
     `README' file for information how to report such a bug to the
     authors.

# additional error messages emitted by the ANSI-C back-end:

*500: % expected
*501: Undefined flag name
*502: This flag only applies to types
*503: This flag only applies to declarations
*504: Can't define procedure body unless interface has CODE_FILE
*505: This flag cannot be used here
*506: FILE, OBJ, or LIB expected
*507: FOREIGN or INTERFACE expected
*508: Calling convention not supported
*509: System flags not enabled for this module
*510: Link name already specified
*511: Flag or string expected
*512: Flag expected
*513: Can't create a library if a module links in an object file
*514: Can't open file `%'
*515: File with library summary doesn't start with right key
*516: Flag % not applicable to this object
*517: Varargs parameter must follow a normal parameter
*518: Calling convention `%' does not support varargs parameter 
*519: CSTRING not applicable to this pointer type
*520: VTABLE can only be set on records without base type

*600: Warning: This flag is already set
*601: Warning: Runtime check `%' not supported
*602: Library imported as `%' calls itself `%'
